<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../fs-styles/fs-styles.html">
<link rel="import" href="../wc-i18n/wc-i18n.html">
<link rel="import" href="../fs-metrics/fs-metrics.html">
<link rel="import" href="../fs-inner-html/fs-inner-html.html">
<link rel="import" href="../fs-dialog/fs-modal-dialog.html">
<link rel="import" href="../fs-icon/fs-icon.html">

<dom-module id="fs-album-slideshow">
  <template>
    <style include='fs-styles'>
      .flex-row-between {
        display: flex;
        justify-content: space-between;
        align-content: center;
      }
      .flex-column {
        display: flex;
        justify-content: flex-start;
        flex-direction: column;
        align-content: center;
      }
      .flex-column span {
        margin-bottom: 10px;
        display: inline-block;
      }
      .flex-column span fs-icon {
        vertical-align: sub;
      }
      .flex-column small:first-of-type {
        margin-bottom: 15px;
      }
      .flex-column small:last-of-type {
        margin-bottom: 5px;
      }
      .toggleSelects {
        -webkit-user-select: none;
        user-select: none;
      }
      .toggleSelects fs-icon {
        margin-right: 5px;
      }
      #slideshowOptions .fs-dialog__close {
        display: none;
      }
      #slideshowOptions #dialogBody {
        max-width: 260px;
        border-radius: 4px;
        padding: 15px 20px;
      }
      #slideShow #dialogBody {
        padding: 0;
      }
      #slideShow .fs-dialog__close {
        z-index: 1000;
        color: #ffffff;
      }
      .play-slideshow-btn-icon {
        vertical-align: sub;
        margin-right: 4px;
      }
      .slide-container {
        background-color: #333331;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
        max-height: 100%;
        max-width: 100%;
        padding-top: 56px;
      }
      .img-container {
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        height: 100%;
        width: 100%;
      }
      .end-of-slideshow-container {
        height: 100%;
        width: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        position: absolute;
      }
      .end-of-slideshow-container > * {
        color: #ffffff;
      }
      .end-btn-container {
        width: 160px;
        margin-top: 20px;
      }
      .end-btn {
        height: 72px;
        width: 72px;
        align-items: center;
        justify-content: center;
        background-color: #ffffff;
        border-radius: 4px;
      }
      .end-btn:hover {
        cursor: pointer;
      }
      .end-btn span {
        margin-bottom: 0;
        margin-top: 5px;
      }
      .slide-img {
        max-height: 100%;
        max-width: 100%;
      }
      .phaudio-container {
        display: inline-flex;
        align-items: baseline;
        padding: 15px 25px;
        background-color: #ffffff;
        border-radius: 90px;
        position: absolute;
        left: 40px;
        top: 0;
      }
      *[hidden] {
        display: none !important;
      }
      .playing-animation {
        height: 17px;
        width: 17px;
      }
      .bars-container {
        position: relative;
        margin: 0 10px;
      }
      .bar {
        background: #666666;
        bottom: 1px;
        height: 3px;
        position: absolute;
        width: 3px;
        animation: sound 0ms -800ms linear infinite alternate;
        transition: 1s all ease;
      }

      .paused .bar {
        animation: none;
      }
      .bar:nth-child(1) {
        left: 1px;
        animation-duration: 474ms;
      }

      .bar:nth-child(2) {
        left: 5px;
        animation-duration: 433ms;
      }

      .bar:nth-child(3) {
        left: 9px;
        animation-duration: 407ms;
      }

      .bar:nth-child(4) {
        left: 13px;
        animation-duration: 458ms;
      }
      .fadeInAnimation {
        animation: 300ms ease-in forwards fadeIn;
      }
      .fadeOutAnimation {
        animation: 300ms ease-out forwards fadeOut;
      }
      @keyframes sound {
        0% {
          opacity: .35;
          height: 3px;
        }
        100% {
          opacity: 1;
          height: 15px;
        }
      }
      @keyframes fadeIn {
        0% {
          opacity:0;
        }
        100% {
          opacity:1;
        }
      }
      @keyframes fadeOut {
        0% {
          opacity:1;
        }
        100% {
          opacity:0;
        }
      }
      @media screen and (max-width: 480px) {
        #slideshowOptions .fs-dialog__close {
          display: block;
        }
        #slideshowOptions #dialogBody {
          padding: 50px 30px;
        }
      }
    </style>
    <!-- Slideshow modal -->
    <fs-modal-dialog id="slideShow" keep-fullscreen on-fs-dialog-close="handleSlideshowClose">
      <div role="dialog" id="dialogBody" class="fs-dialog__body">
        <div class="slide-container">
          <div class="img-container">
            <div role="timer" class="phaudio-container" hidden$="[[!shouldShowPhaudioPlayer(currentSlideIndex, artifacts.length, totalSlideshowDurationWithAudio, playAudio)]]">
              <fs-icon icon="audio-recording-small"></fs-icon>
               <!-- PLAYING ANIMATION -->
               <div class="bars-container">
                 <div id="bars" class$="{{audioBarsActive(isAudioPlaying)}}">
                   <div class="bar"></div>
                   <div class="bar"></div>
                   <div class="bar"></div>
                   <div class="bar"></div>
                 </div>
               </div>
              <!-- AUDIO DURATION -->
              <span class="audio-timer">{{audioCurrentTime}}</span>
              <audio id="audioPlayer" src$="[[getCurrentSlideAudioSrc(currentSlideIndex, artifacts.length, totalSlideshowDurationWithAudio)]]" on-timeupdate="updateAudioTime"></audio>
            </div>
            <img id="slideImage" class="slide-img" src="[[getCurrentSlideSrc(currentSlideIndex, artifacts.length)]]" alt="[[getCurrentSlideAltText(currentSlideIndex, artifacts.length)]]" on-load="fadeInSlide" />
            <div class$="end-of-slideshow-container flex-column [[shouldToggleFade(isSlideshowFinished)]]" hidden="[[!isSlideshowFinished]]">
              <h1>[[i18n('end_menu_end_of_slideshow')]]</h1>
              <div class="flex-row-between end-btn-container">
                <button class="end-btn flex-column" on-click="restartSlideshow">
                  <fs-icon icon="revert-small"></fs-icon>
                  <span>[[i18n('end_menu_replay')]]</span>
                </button>
                <button class="end-btn flex-column" on-click="handleSlideshowClose">
                  <fs-icon icon="close-small-white" color="#333331"></fs-icon>
                  <span>[[i18n('end_menu_close')]]</span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </fs-modal-dialog>
    <!-- Slideshow Config modal -->
    <fs-modal-dialog id="slideshowOptions" transition="from-bottom" dismiss-on-blur on-fs-dialog-confirm="beginSlideshow">
      <div id="dialogBody" class="fs-dialog__body">
        <div class="flex-column">
          <small>[[i18n('slideshow_options_desc')]]</small>
          <span on-click="togglePlayAudio" class="toggleSelects" role="switch">
            <fs-icon icon="toggle-off-state-small" hidden="[[playAudio]]"></fs-icon>
            <fs-icon icon="toggle-on-state-small" hidden="[[!playAudio]]"></fs-icon>
            [[i18n('slideshow_options_play_audio')]]
          </span>
          <span on-click="toggleLoopSlideshow" class="toggleSelects" role="switch">
            <fs-icon icon="toggle-off-state-small" hidden="[[loopSlideshow]]"></fs-icon>
            <fs-icon icon="toggle-on-state-small" hidden="[[!loopSlideshow]]"></fs-icon>
            [[i18n('slideshow_options_loop_slideshow')]]
          </span>
          <small>
            <fs-inner-html value="[[slideshowCountAndTime]]"></fs-inner-html>
          </small>
        </div>
        <button class="fs-button fs-button--recommended" data-dialog-confirm disabled="[[!artifacts.length]]">
          <span>
            <fs-icon icon="play-small" color="var(--fs-color-white)" class="play-slideshow-btn-icon"></fs-icon>[[i18n('play_slideshow')]]
          </span>
        </button>
      </div>
    </fs-modal-dialog>
  </template>
</dom-module>
<script>
(function() {
  // Set up dialog as a "global" dialog to prevent overlapping elements (on top of dialog)
  FS.dialog.register('fs-album-slideshow');

  // START of Fullscreen Polyfill
  if (!Element.prototype.requestFullscreen) {
    Element.prototype.requestFullscreen = Element.prototype.mozRequestFullscreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen;
  }
  if (!document.exitFullscreen) {
    document.exitFullscreen = document.mozExitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
  }

  if (!document.fullscreenElement) {
    Object.defineProperty(document, 'fullscreenElement', {
      get: function() {
        return document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement;
      }
    });
  }
  // END of Fullscreen Polyfill

  Polymer({

    is: 'fs-album-slideshow',

    behaviors: [
      WCI18n(),
      FsBehaviors.Metrics
    ],

    properties: {
      albumSlideshowEx: {
        type: Boolean,
        value: function(){ return FS.showEx('albumSlideshowEx'); }
      },
       artifacts: {
        type: Array,
        value: function() { return []; }
      },
      isAudioPlaying: {
        type: Boolean,
        value: false
      },
      playAudio: {
        type: Boolean,
        value: true
      },
      loopSlideshow: {
        type: Boolean,
        value: true
      },
      isSlideshowPaused: {
        type: Boolean,
        value: false
      },
      stopSlideshow: {
        type: Boolean,
        value: false
      },
      isSlideshowFinished: {
        type: Boolean,
        value: false
      },
      // Need to set a bool to know when speed has changed to update the
      // initial slideshow time w/o having to re-calc the time every time they open it
      speedHasChanged: {
        type: Boolean,
        value: false
      },
      // All time listed below is in Milliseconds
      slideshowTransitionTime: {
        type: Number,
        value: 700
      },
      slideDisplayTime: {
        type: Number,
        value: 4000
      },
      displayedSlideshowDuration: {
        type: Number,
        value: 0
      },
      totalSlideshowDurationWithAudio: {
        type: Number,
        value: 0
      },
      totalSlideshowDurationWithoutAudio: {
        type: Number,
        value: 0
      },
      currentSlideIndex: {
        type: Number,
        value: 0
      },
      slideshowCountAndTime: {
        type: String,
        value: ''
      },
      audioCurrentTime: {
        type: String,
        value: '0:00'
      },
      // Allowing the setTimeout to be ended (to clean up timer) when slideshow closes
      activeTimeout: {
        type: String,
        value: ''
      }
    },

    ready: function() {
      this.listen(document, 'gallery-view-changed', 'closeSlideshowOptions');
      document.addEventListener('keyup', this.handleKeyPress.bind(this));
      // Fullscreenchange event isn't standardized yet
      /* Standard syntax */
      this.$.slideShow.addEventListener('fullscreenchange', this.exitHandler.bind(this));
      /* Safari and Opera */
      this.$.slideShow.addEventListener('webkitfullscreenchange', this.exitHandler.bind(this));
      /* Firefox */
      this.$.slideShow.addEventListener('mozfullscreenchange', this.exitHandler.bind(this));
      /* IE / Edge */
      this.$.slideShow.addEventListener('msfullscreenchange', this.exitHandler.bind(this));
    },

    // None of the "ESC" keyboard events work when in fullscreen
    exitHandler: function (e) {
      // fullscreenElement is 'null' when leaving fullscreen mode
      if (!document.fullscreenElement) {
        this.$.slideShow.close();
      }
    },

    handleKeyPress: function(e) {
      if (!this.isSlideshowOpen()) return;
      const player = this.$.audioPlayer;
      switch (e.key) {
        case " ": /* SPACE */
          if (this.isSlideshowPaused) {
            this.isSlideshowPaused = false;
            this.stopSlideshow = false;
            this.runSlides();
          } else {
            // Pause the slideshow too
            this.stopSlideshow = true;
            clearTimeout(this.activeTimeout);
            if (this.$.audioPlayer.duration) {
              this.isAudioPlaying = false;
              this.$.audioPlayer.pause();
            }
            this.isSlideshowPaused = true;
          }
          break;
        case "ArrowLeft": /* Left Arrow */
          this.stopSlideshow = true;
          clearTimeout(this.activeTimeout);
          this.prevSlide();
          break;
        case "ArrowRight": /* Right Arrow */
          this.stopSlideshow = true;
          clearTimeout(this.activeTimeout);
          this.nextSlide();
          break;
      
        default:
          break;
      }
    },

    /**
     * Resets some dynamic variables used in the slideshow
     */
    reset: function() {
      this.currentSlideIndex = 0;
      // Stop audio and reset track to beginning (they may have stopped on the first slide)
      this.$.audioPlayer.pause();
      this.$.audioPlayer.currentTime = 0;
    },

    /**
     * Closes the slideshow options dialog if open and the browser back button is clicked
     */
    closeSlideshowOptions: function() {
      const slideshowOptions = this.$.slideshowOptions;
      if (slideshowOptions.opened) slideshowOptions.close();
    },

    /**
     * Opens the initial slideshow options dialog
     */
    openSlideshowOptions: function(data) {
      const validArtifacts = (data.artifacts && data.artifacts.length) ? this.validateArtifacts(data.artifacts) : [];
      // Make sure we have something "new" before resetting the artifacts array and other data
      const artifactsString = JSON.stringify(this.artifacts);
      const eventArtifactsString = JSON.stringify(validArtifacts);
      if (artifactsString !== eventArtifactsString) {
        this.reset();
        this.displayedSlideshowDuration = 0;
        this.set('artifacts', validArtifacts);
      }
      this.stopSlideshow = false;
      this.isSlideshowFinished = false;
      this.setSlideshowCountAndTime();
      this.$.slideshowOptions.open();
    },
    
    /**
     * Returns the "valid" set of artifacts in the album that can be used in the slideshow
     * The currently valid types are:
     * [Category] > [Content Category]
     *    - IMAGE > PHOTOS (with or without associated audio files)
     *    - IMAGE > DOCUMENT
     */
    validateArtifacts: function(artifacts) {
      // Don't need to check for 'Phaudios' since they will always be included with a photo filter 
      const validGroup = artifacts.filter(item => (item.category === 'IMAGE' && (item.contentCategory === 'PHOTO' || item.contentCategory === 'DOCUMENT')));
      return validGroup.slice(0);
    },

    // Slide animation transitions
    fadeInSlide: function() {
      this.$.slideImage.style.animation = `300ms ease-in forwards fadeIn`;
    },
    fadeOutSlide: function() {
      this.$.slideImage.style.animation = `${this.slideshowTransitionTime}ms ease-out forwards fadeOut`;
    },

    shouldToggleFade: function(isSlideshowFinished) {
      return isSlideshowFinished ? 'fadeInAnimation' : 'fadeOutAnimation';
    },

    /**
     * Restarts slideshow. Only called when looping is not enabled
     */
    restartSlideshow: function() {
      this.fadeOutSlide();
      this.isSlideshowFinished = false;
      this.currentSlideIndex = 0;
      this.runSlides();
    },

    /**
     * Moves to the next slide
     */
    nextSlide: function() {
      if ((this.currentSlideIndex + 1) < this.artifacts.length) {
        this.fadeOutSlide();
        this.currentSlideIndex += 1;
      } else if (this.currentSlideIndex === (this.artifacts.length - 1)) {
        if (this.loopSlideshow) {
          this.fadeOutSlide();
          this.currentSlideIndex = 0;
        } else {
          this.isSlideshowFinished = true;
          return;
        }
      }
      this.isSlideshowFinished = false;
      if (this.stopSlideshow) this.stopSlideshow = false;
      this.runSlides();
    },

    /**
     * Moves to the previous slide
     */
    prevSlide: function() {
      // If 'fadeOutSlide' is moved out here the slide would fade on a non-looping prev click on the first slide
      if ((this.currentSlideIndex - 1) >= 0) {
        this.fadeOutSlide();
        this.currentSlideIndex -= 1;
      } else if ((this.currentSlideIndex === 0) && this.loopSlideshow) {
        this.fadeOutSlide();
        this.currentSlideIndex = this.artifacts.length - 1;
      }
      this.isSlideshowFinished = false;
      if (this.stopSlideshow) this.stopSlideshow = false;
      this.runSlides();
    },

    /**
     * Timer to pause slide progression for the determined amount of time
     */
    timer: function(delay) {
      return new Promise(res => {
        this.activeTimeout = setTimeout(res, delay);
      });
    },

    /**
     * Manages slide progression
     */
    runSlides: async function() {
      if (this.stopSlideshow) return;
      const artifact = this.artifacts[this.currentSlideIndex];
      const player = this.$.audioPlayer;
      let delayTime = this.playAudio ? artifact.slideLength : this.slideDisplayTime;
      if (this.playAudio && artifact.hasPhaudio) {
        this.isAudioPlaying = true;
        this.$.audioPlayer.play();
        // Allow delay to be reduced if audio is "resumed" from a paused state
        const duration = isNaN(player.duration) ?  0 : player.duration * 1000;
        const current = player.currentTime * 1000;
        if (current !== 0) delayTime = (duration - current);
      }
      await this.timer(delayTime - 200); // Allow time for image to render
      if (!this.stopSlideshow) this.nextSlide();
    },

    /**
     * Opens and kicks-off the slideshow
     */
    beginSlideshow: function(e) {
      if (e.target.id === 'slideshowOptions' && this.artifacts.length) {
        this.$.slideshowOptions.close();
        this.runSlides();
        this.$.slideShow.open();
        this.$.slideShow.requestFullscreen();
      }
    },

    /**
     * Stops slideshow and resets slideshow state
     */
    handleSlideshowClose: function() {
      clearTimeout(this.activeTimeout);
      if (document.fullscreenElement) document.exitFullscreen();
      this.stopSlideshow = true;
      this.reset();
    },

    handleAudioTimeUpdate: function(audioEl, artifactIndex) {
      let offset = 0;
        const dur = (audioEl.duration * 1000); // Audio duration is given in seconds
        // Phaudios shouldn't prevent photo from showing for at least the 'slideDisplayTime'
        if (dur < this.slideDisplayTime) offset = this.slideDisplayTime - dur;
        this.artifacts[artifactIndex].slideLength = (dur + offset);
        this.totalSlideshowDurationWithAudio += (dur + this.slideshowTransitionTime + offset);

        if (this.playAudio) {
          this.artifacts[artifactIndex].phaudioDuration = audioEl.duration;
          this.displayedSlideshowDuration = this.playAudio ? this.totalSlideshowDurationWithAudio : this.totalSlideshowDurationWithoutAudio;
          this.setSlideshowCountAndTime();
        }
    },

    /**
     * Obtain the audio file duration via the Audio API
     */
    getAudioDuration: function(audioUrl, artifactIndex) {
      const audio = new Audio(audioUrl)
      audio.addEventListener('loadedmetadata', () => { this.handleAudioTimeUpdate(audio, artifactIndex) })
    },

    /**
     * Determines the duration of the slideshow, with and without audio playing.
     */
    calcSlideshowDuration: function() {
      const nonAudioSlideTime = (this.slideDisplayTime + this.slideshowTransitionTime);
      // Add up all slide times (all images show regardless of audio playing)
      this.totalSlideshowDurationWithoutAudio = (this.artifacts.length * nonAudioSlideTime);
      this.totalSlideshowDurationWithAudio = 0;

      this.artifacts.forEach((item, index) => {
        if (item.associatedArtifacts && item.associatedArtifacts.artifact.length && item.associatedArtifacts.artifact[0].category === 'AUDIO') {
          item.hasPhaudio = true;
          // Get Audio time and add it to totalSlideshowDurationWithAudio
          this.getAudioDuration(item.associatedArtifacts.artifact[0].url, index);
        } else {
          // Add all the non-audio slide times to 'totalSlideshowDurationWithAudio'
          this.totalSlideshowDurationWithAudio += nonAudioSlideTime;
          item.slideLength = this.slideDisplayTime;
        }
      });

      this.displayedSlideshowDuration = this.playAudio ? this.totalSlideshowDurationWithAudio : this.totalSlideshowDurationWithoutAudio;
    },

    /**
     * Formats the slideshow time shown in a "[minutes]:[seconds (2-digit)]" format
     */
    formatDisplayTime: function(timeInMS) {
      const minutes = (Math.floor(Math.floor(timeInMS / 1000) / 60) % 60);
      const seconds = (Math.floor(timeInMS / 1000) % 60);
      const formattedSeconds = (seconds < 10) ? `0${seconds}` : seconds;
      return `${minutes}:${formattedSeconds}`;
    },

    /**
     * Updates the displayed slide count and slideshow duration
     */
    setSlideshowCountAndTime: function() {
      if (!this.i18n) return;
      let text = this.i18n('slideshow_options_length');
      if (text) {
        if ((!this.displayedSlideshowDuration || this.speedHasChanged) && this.artifacts.length) this.calcSlideshowDuration();

        text = text.replace('{count}', `<span>${this.artifacts.length}</span>`);
        text = text.replace('{min}', `<span>${this.formatDisplayTime(this.displayedSlideshowDuration)}</span>`);
        this.slideshowCountAndTime = text;
      }
    },

    /**
     * Returns bool of if slideshow is open
     */
    isSlideshowOpen: function() {
      return !!this.$.slideShow.opened;
    },

    /**
     * Returns the 'url' from the current slide (for displaying the photo)
     */
    getCurrentSlideSrc: function(currentSlideIndex) {
      if (!this.artifacts || !this.artifacts.length) return '';
      const current = this.artifacts[currentSlideIndex];
      if (current.mimeType === 'image/tiff') {
        // Most browsers can't display Tiff files, have to use the generated jpg
        return current.deepZoomLiteUrl || current.thumbUrl;
      }
      return current.url;
    },
    /**
     * Returns the 'title' from the current slide (for 'alt' text)
     */
    getCurrentSlideAltText: function(currentSlideIndex) {
      if (!this.artifacts || !this.artifacts.length) return '';
      return this.artifacts[currentSlideIndex].title || '';
    },
    /**
     * Returns the 'associated audio' source from the current slide
     */
     getCurrentSlideAudioSrc: function(currentSlideIndex, artifactsLength) {
      if (!artifactsLength || !this.playAudio || !this.artifacts[currentSlideIndex].hasPhaudio) return '';
      return this.artifacts[currentSlideIndex].associatedArtifacts.artifact[0].url || '';
    },
    /**
     * Toggles the "play photo-audio" slider and updates the displayed slideshow duration
     */
    togglePlayAudio: function() {
      this.playAudio = !this.playAudio;
      this.displayedSlideshowDuration = this.playAudio ? this.totalSlideshowDurationWithAudio : this.totalSlideshowDurationWithoutAudio;
      this.setSlideshowCountAndTime();
    },
    /**
     * Toggles the "loop slideshow" slider
     */
    toggleLoopSlideshow: function() {
      this.loopSlideshow = !this.loopSlideshow;
    },
    /**
     * Determines if the Phaudio player should be shown
     */
    shouldShowPhaudioPlayer: function(currentSlideIndex, artifactsLength) {
      if (!artifactsLength) return false;
      return this.artifacts[currentSlideIndex].hasPhaudio && this.playAudio;
    },
    /**
     * Sets if the audio bars are animating or not
     */
    audioBarsActive: function(isAudioPlaying) {
      return isAudioPlaying ? 'playing-animation' : 'playing-animation paused';
    },
    updateAudioTime: function() {
      const player = this.$.audioPlayer;
      const duration = isNaN(player.duration) ?  0 : player.duration * 1000;
      const current = player.currentTime * 1000;
      this.isAudioPlaying = ((duration - current) !== 0 && !this.isSlideshowPaused);
      this.audioCurrentTime = this.formatDisplayTime(duration - current);
    },
  });
})();
</script>
