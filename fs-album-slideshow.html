<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../fs-styles/fs-styles.html">
<link rel="import" href="../wc-i18n/wc-i18n.html">
<link rel="import" href="../fs-metrics/fs-metrics.html">
<link rel="import" href="../fs-inner-html/fs-inner-html.html">
<link rel="import" href="../fs-dialog/fs-modal-dialog.html">
<link rel="import" href="../fs-dialog/fs-anchored-dialog.html">
<link rel="import" href="../fs-icon/fs-icon.html">
<link rel="import" href="../fs-alert/fs-inline-alert.html">
<link rel="import" href="../fs-social-menu/fs-social-menu.html">

<dom-module id="fs-album-slideshow">
  <template>
    <style include='fs-styles'>
      .flex-row-between {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }
      .flex-column {
        display: flex;
        justify-content: flex-start;
        flex-direction: column;
      }
      .flex-column span {
        margin-bottom: 10px;
        display: inline-block;
      }
      .flex-column span fs-icon {
        vertical-align: sub;
      }
      .flex-column small:first-of-type {
        margin-bottom: 15px;
      }
      .flex-column small:last-of-type {
        margin-bottom: 5px;
      }
      .flex-center-center {
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .toggleSelects {
        -webkit-user-select: none;
        user-select: none;
      }
      .toggleSelects fs-icon {
        margin-right: 5px;
      }
      #slideshowOptions .fs-dialog__close {
        display: none;
      }
      #slideshowOptions #dialogBody {
        max-width: 260px;
        border-radius: 4px;
        padding: 15px 20px;
      }
      #slideShow #dialogBody, #slideshowSpeedModal .fs-dialog__body {
        padding: 0;
      }
      #slideShow .fs-dialog__close {
        z-index: 1000;
        color: #ffffff;
        display: block;
      }
      #slideShow .share-button {
        align-items: center;
        background : none;
        border-radius: 6px;
        border: 1px solid white;
        color: #ffffff;
        display: flex;
        padding: 9px 18px;
        position: absolute;
        right: 60px;
        top: 5px;
        z-index: 2;
      }
      #slideShow .share-button fs-icon {
        margin-right: 10px;
      }
      .play-slideshow-btn-icon {
        vertical-align: sub;
        margin-right: 4px;
      }
      .img-container {
        position: relative;
        height: 100%;
        width: 100%;
      }
      .slide-container {
        background-color: #333331;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
        max-height: 100%;
        max-width: 100%;
        padding-top: 56px;
      }
      .end-of-slideshow-container {
        background-color: rgba(0,0,0,0.5);
        position: absolute;
        top: -56px;
        width: 100%;
        height: calc(100% + 56px);
        z-index: 30;
      }
      .end-of-slideshow-container > * {
        color: #ffffff;
      }
      .end-btn-container {
        width: 160px;
        margin-top: 20px;
      }
      .end-btn {
        height: 72px;
        width: 72px;
        align-items: center;
        justify-content: center;
        background-color: #ffffff;
        border-radius: 4px;
      }
      .end-btn:hover {
        cursor: pointer;
      }
      .end-btn span {
        margin-bottom: 0;
        margin-top: 5px;
      }
      .slide-img {
        max-height: 100%;
        max-width: 100%;
      }
      .phaudio-container {
        display: inline-flex;
        align-items: baseline;
        padding: 15px 25px;
        background-color: #ffffff;
        border-radius: 90px;
        position: absolute;
        left: 40px;
        top: 0;
        z-index: 10;
      }
      .audio-loading-error {
        position: absolute;
        top: 60px;
        left: 0;
        width: 240px;
        width: max-content;
      }
      .slideshow-control-container {
        position: absolute;
        bottom: 45px;
        width: 435px;
        max-width: 100vw;
        height: 170px;
        background-color: rgba(0,0,0,0.6);
        justify-content: center;
        border-radius: 4px;
        z-index: 20;
      }
      .controls-index {
        padding: 5px 10px;
        border-radius: 15px;
        background-color: #000000;
        margin-bottom:25px;
        height: 25px;
      }
      .controls-index * {
        color: #ffffff;
      }
      #slideshowSpeedModal header {
        border-bottom: 1px solid #dddddd;
      }
      #slideshowSpeedModal .fs-dialog__body {
        overflow: hidden;
        border-radius: 4px;
        padding: 10px 0;
      }
      .speed-btn {
        padding: 10px 40px;
        position: relative;
      }
      .speed-btn span {
        margin-bottom: 0;
      }
      .speed-btn fs-icon {
        position: absolute;
        left: 12px;
        top: 12px;
      }
      .speed-btn:hover {
        cursor: pointer;
        background-color: #dddddd;
      }
      .controls-btn-container {
        width: 305px;
      }
      .play-btn {
        left: 27px;
      }
      .prev-btn, .next-btn {
        top: 13px;
      }
      .prev-btn {
        left: 11px;
      }
      .next-btn {
        left: 14px;
      }
      .settings-btn {
        top: 7px;
      }
      .pause-btn rect {
        fill: #333331;
      }
      .controls-large {
        height: 70px;
        width: 70px;
      }
      .controls-large:hover, .controls-medium:hover, .controls-small:hover {
        cursor: pointer;
        opacity: 0.6;
      }
      .controls-large, .controls-medium, .controls-small {
        background-color: #ffffff;
        border-radius: 50%;
        border: none;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
      }
      .controls-large fs-icon, .controls-medium fs-icon, .controls-small fs-icon {
        position: absolute;
      }
      .controls-medium {
        height: 40px;
        width: 40px;
      }
      .controls-medium fs-icon svg {
        /* Icon doesn't include background */
        transform: scale(1.5);
      }
      .controls-small {
        height: 30px;
        width: 30px;
      }
      .loop-icon {
        position: absolute;
        right: 2px;
      }
      .controls-btn.active-loop-btn path:nth-child(1),
      .controls-btn.active-loop-btn path:nth-child(3) {
        fill: #ffffff;
      }
      .controls-btn.active-loop-btn path:nth-child(2),
      .controls-btn.active-loop-btn path:nth-child(4) {
        stroke: #ffffff;
      }
      .controls-btn.active-loop-btn {
        background-color: #87B940;
      }
      *[hidden] {
        display: none !important;
      }
      .playing-animation {
        height: 17px;
        width: 17px;
      }
      .bars-container {
        position: relative;
        margin: 0 10px;
      }
      .bar {
        background: #666666;
        bottom: 1px;
        height: 3px;
        position: absolute;
        width: 3px;
        animation: sound 0ms -800ms linear infinite alternate;
        transition: 1s all ease;
      }

      .paused .bar {
        animation: none;
      }
      .bar:nth-child(1) {
        left: 1px;
        animation-duration: 474ms;
      }

      .bar:nth-child(2) {
        left: 5px;
        animation-duration: 433ms;
      }

      .bar:nth-child(3) {
        left: 9px;
        animation-duration: 407ms;
      }

      .bar:nth-child(4) {
        left: 13px;
        animation-duration: 458ms;
      }
      .fadeInAnimation {
        animation: 300ms ease-in forwards fadeIn;
      }
      .fadeOutAnimation {
        animation: 500ms ease-out forwards fadeOut;
      }

      @keyframes sound {
        0% {
          opacity: .35;
          height: 3px;
        }
        100% {
          opacity: 1;
          height: 15px;
        }
      }
      @keyframes fadeIn {
        0% {
          opacity:0;
        }
        100% {
          opacity:1;
        }
      }
      @keyframes fadeOut {
        0% {
          opacity:1;
        }
        100% {
          opacity:0;
        }
      }
      @media screen and (max-width: 979px) {
        .phaudio-container {
          left: 15px
        }
        .slideshow-control-container {
          /* Account for header area */
          height: calc(100% + 56px);
          bottom: 0;
          width: 100%;
          justify-content: flex-end;
          padding-bottom: 30px;
        }
        #slideshowOptions .fs-dialog__close {
          display: block;
        }
        #slideshowOptions #dialogBody {
          padding: 50px 30px;
        }
      }
      @media screen and (max-width: 400px) {
        .slideshow-control-container {
          height: 170px;
          width: 435px;
          justify-content: center;
          bottom: 0;
          border-radius: 0;
          border-top-left-radius: 4px;
          border-top-right-radius: 4px;
        }
      }
    </style>
    <!-- Slideshow modal -->
    <fs-modal-dialog id="slideShow" keep-fullscreen on-fs-dialog-close="handleSlideshowClose">
      <div role="dialog" id="dialogBody" class="fs-dialog__body">
        <fs-social-menu hidden="[[!shareSlideshowEx]]" open-in-new-tab>
          <button class="share-button" on-click="toggleSocialMenu">
            <fs-icon icon="share-batch-small" color="var(--fs-color-white)"></fs-icon>
            [[i18n('share')]]
          </button>
        </fs-social-menu>
        <button class="fs-dialog__close" data-dialog-dismiss="" data-test-close="" aria-label="[[i18n('end_menu_close')]]">
          <svg aria-hidden="true" width="13" height="13" viewBox="0 0 13 13" preserveAspectRatio="xMidYMin"><g transform="translate(-1.000000, -1.000000)"><path d="M13 2L2 13M2 2L13 13" stroke="currentColor" stroke-width="2.5"></path></g></svg>
        </button>
        <div class="slide-container">
          <div class="img-container flex-center-center">
            <div role="timer" class="phaudio-container" hidden$="[[!shouldShowPhaudioPlayer(currentSlideIndex, artifacts.length, totalSlideshowDurationWithAudio, playAudio)]]">
              <fs-icon icon="audio-recording-small"></fs-icon>
               <!-- PLAYING ANIMATION -->
               <div class="bars-container">
                 <div id="bars" class$="{{audioBarsActive(isAudioPlaying)}}">
                   <div class="bar"></div>
                   <div class="bar"></div>
                   <div class="bar"></div>
                   <div class="bar"></div>
                 </div>
               </div>
              <!-- AUDIO DURATION -->
              <span class="audio-timer">{{audioCurrentTime}}</span>
              <fs-inline-alert type="error" class="audio-loading-error" hidden="[[!showAudioError]]">
                <p>[[i18n('slideshow_controls_audio_error')]]</p>
              </fs-inline-alert>
            </div>
            <img id="slideImage" class="slide-img" src="[[getCurrentSlideSrc(currentSlideIndex, artifacts.length)]]" alt="[[getCurrentSlideAltText(currentSlideIndex, artifacts.length)]]" on-load="fadeInSlide" />
            <div class$="end-of-slideshow-container flex-column flex-center-center [[shouldToggleFade(isSlideshowFinished)]]" hidden="[[!isSlideshowFinished]]">
              <h1>[[i18n('end_menu_end_of_slideshow')]]</h1>
              <div class="flex-row-between end-btn-container">
                <button class="end-btn flex-column" on-click="restartSlideshow" title="[[i18n('end_menu_replay')]]">
                  <fs-icon icon="revert-small"></fs-icon>
                  <span>[[i18n('end_menu_replay')]]</span>
                </button>
                <button class="end-btn flex-column" id="slideShowEnd" on-click="handleSlideshowClose" title="[[i18n('end_menu_close')]]">
                  <fs-icon icon="close-small-white" color="#333331"></fs-icon>
                  <span>[[i18n('end_menu_close')]]</span>
                </button>
              </div>
            </div>
            <div id="slideshowControls" class$="slideshow-control-container flex-column flex-center-center [[updateControlsVisibility(showControls, isSlideshowFinished)]]">
              <div class="controls-index">
                <span>
                  <fs-inner-html value="[[getSlideIndexPosition(currentSlideIndex, artifacts.length, i18n)]]"></fs-inner-html>
                </span>
              </div>
              <div class="flex-row-between controls-btn-container">
                <button class$="controls-btn controls-small [[isActiveLoopBtn(loopSlideshow)]]" on-click="toggleLoopSlideshow" title="[[i18n('slideshow_options_loop_slideshow')]]">
                  <svg width="25" height="25" fill="none" xmlns="http://www.w3.org/2000/svg" class="loop-icon" title="[[i18n('slideshow_options_loop_slideshow')]]">
                    <path d="M17.924 10.612l-2.316.023c-.23 0-.305.159-.164.341l3.78 4.906c.14.182.37.182.512-.008l3.675-4.989c.141-.19.067-.341-.17-.341l-2.317.023" fill="#333331"/>
                    <path d="M19.624 11.833c-.037-3.806-3.088-6.854-6.816-6.817A6.664 6.664 0 008.287 6.86" stroke="#333331" stroke-width="3" stroke-miterlimit="10" stroke-linecap="round"/>
                    <path d="M7.069 14.388l2.316-.023c.23 0 .305-.159.164-.341L5.762 9.111c-.141-.182-.371-.182-.512.007l-3.676 4.99c-.14.189-.067.34.171.34l2.317-.022" fill="#333331"/>
                    <path d="M16.706 18.141a6.684 6.684 0 01-4.521 1.843c-3.728.037-6.78-3.01-6.817-6.817" stroke="#333331" stroke-width="3" stroke-miterlimit="10" stroke-linecap="round"/>
                  </svg>
                </button>
                <button class="controls-btn controls-medium" on-click="handlePrevSlide" title="[[i18n('slideshow_controls_prev_slide')]]">
                  <fs-icon class="prev-btn" icon="previous-flagged-image-small" title="[[i18n('slideshow_controls_prev_slide')]]"></fs-icon>
                </button>
                <button class="controls-btn controls-large" on-click="handlePlayPauseSlideshow" title="[[getPlayPauseString(isSlideshowPaused, artifacts.length, totalSlideshowDurationWithAudio)]]">
                  <fs-icon class="play-btn" icon="play-white-medium" color="#333331" hidden="[[!isSlideshowPaused]]" title="[[getPlayPauseString(isSlideshowPaused, artifacts.length, totalSlideshowDurationWithAudio)]]"></fs-icon>
                  <fs-icon class="pause-btn" icon="pause-medium-white" color="#333331" hidden="[[isSlideshowPaused]]" title="[[getPlayPauseString(isSlideshowPaused, artifacts.length, totalSlideshowDurationWithAudio)]]"></fs-icon>
                </button>
                <button class="controls-btn controls-medium" on-click="handleNextSlide" title="[[i18n('slideshow_controls_next_slide')]]">
                  <fs-icon class="next-btn" icon="next-flagged-image-small" title="[[i18n('slideshow_controls_next_slide')]]"></fs-icon>
                </button>
                <button class="controls-btn controls-small" on-click="openSlideshowSpeedModal" title="[[i18n('slideshow_controls_slideshow_speed')]]">
                  <fs-icon class="settings-btn" icon="tools-small" title="[[i18n('slideshow_controls_slideshow_speed')]]"></fs-icon>
                </button>
              </div>
            </div>
          </div>
        </div>
        <!-- Slideshow speed stepper modal -->
        <fs-anchored-dialog id="slideshowSpeedModal" transition="from-bottom" no-fullscreen-mobile forced-pointer-direction="down">
          <header>
            <h4>[[i18n('slideshow_controls_slideshow_speed')]]</h4>
          </header>
          <div class="fs-dialog__body">
            <div class="flex-column">
              <!-- Intentionally different speed used than displayed to allow a slower -> faster time in calculation -->
              <div class="speed-btn" role="button" data-speed="2" on-click="updateSpeedSelection">
                <fs-icon icon="replace-check-small" hidden="[[!shouldShowCheckmark(speedSelection, '2')]]"></fs-icon>
                <span>0.5</span>
              </div>
              <div class="speed-btn" role="button" data-speed="1.5" on-click="updateSpeedSelection">
                <fs-icon icon="replace-check-small" hidden="[[!shouldShowCheckmark(speedSelection, '1.5')]]"></fs-icon>
                <span>0.75</span>
              </div>
              <div class="speed-btn" role="button" data-speed="normal" on-click="updateSpeedSelection">
                <fs-icon icon="replace-check-small" hidden="[[!shouldShowCheckmark(speedSelection, 'normal')]]"></fs-icon>
                <span>[[i18n('slideshow_controls_speed')]]</span>
              </div>
              <div class="speed-btn" role="button" data-speed="0.75" on-click="updateSpeedSelection">
                <fs-icon icon="replace-check-small" hidden="[[!shouldShowCheckmark(speedSelection, '0.75')]]"></fs-icon>
                <span>1.25</span>
              </div>
              <div class="speed-btn" role="button" data-speed="0.5" on-click="updateSpeedSelection">
                <fs-icon icon="replace-check-small" hidden="[[!shouldShowCheckmark(speedSelection, '0.5')]]"></fs-icon>
                <span>1.5</span>
              </div>
            </div>
          </div>
        </fs-anchored-dialog>
      </div>
    </fs-modal-dialog>
    <!-- Slideshow Config modal -->
    <fs-modal-dialog id="slideshowOptions" transition="from-bottom" dismiss-on-blur on-fs-dialog-confirm="beginSlideshow">
      <div id="dialogBody" class="fs-dialog__body">
        <div class="flex-column">
          <small>[[i18n('slideshow_options_desc')]]</small>
          <span on-click="togglePlayAudio" class="toggleSelects" role="switch">
            <fs-icon icon="toggle-off-state-small" hidden="[[playAudio]]"></fs-icon>
            <fs-icon icon="toggle-on-state-small" hidden="[[!playAudio]]"></fs-icon>
            [[i18n('slideshow_options_play_audio')]]
          </span>
          <span on-click="toggleLoopSlideshow" class="toggleSelects" role="switch">
            <fs-icon icon="toggle-off-state-small" hidden="[[loopSlideshow]]"></fs-icon>
            <fs-icon icon="toggle-on-state-small" hidden="[[!loopSlideshow]]"></fs-icon>
            [[i18n('slideshow_options_loop_slideshow')]]
          </span>
          <small>
            <fs-inner-html value="[[slideshowCountAndTime]]"></fs-inner-html>
          </small>
        </div>
        <button class="fs-button fs-button--recommended" data-dialog-confirm disabled="[[!artifacts.length]]">
          <span>
            <fs-icon icon="play-small" color="var(--fs-color-white)" class="play-slideshow-btn-icon"></fs-icon>[[i18n('play_slideshow')]]
          </span>
        </button>
      </div>
    </fs-modal-dialog>
  </template>
</dom-module>
<script>
(function() {
  // Set up dialog as a "global" dialog to prevent overlapping elements (on top of dialog)
  FS.dialog.register('fs-album-slideshow');

  // START of Fullscreen Polyfill
  if (!Element.prototype.requestFullscreen) {
    Element.prototype.requestFullscreen = Element.prototype.mozRequestFullscreen || Element.prototype.webkitRequestFullscreen || Element.prototype.msRequestFullscreen;
  }
  if (!document.exitFullscreen) {
    document.exitFullscreen = document.mozExitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
  }

  if (!document.fullscreenElement) {
    Object.defineProperty(document, 'fullscreenElement', {
      get: function() {
        return document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement;
      }
    });
  }
  // END of Fullscreen Polyfill

  Polymer({

    is: 'fs-album-slideshow',

    behaviors: [
      WCI18n(),
      FsBehaviors.Metrics
    ],

    properties: {
      albumSlideshowEx: {
        type: Boolean,
        value: function(){ return FS.showEx('albumSlideshowEx'); }
      },
       artifacts: {
        type: Array,
        value: function() { return []; }
      },
      audioTracks: {
        type: Array,
        value: function() { return []; }
      },
      isAudioPlaying: {
        type: Boolean,
        value: false
      },
      playAudio: {
        type: Boolean,
        value: true
      },
      loopSlideshow: {
        type: Boolean,
        value: false
      },
      isSlideshowPaused: {
        type: Boolean,
        value: false
      },
      stopSlideshow: {
        type: Boolean,
        value: false
      },
      isSlideshowFinished: {
        type: Boolean,
        value: false
      },
      showAudioError: {
        type: Boolean,
        value: false
      },
      showControls: {
        type: Boolean,
        value: true
      },
      isMouseEnter: {
        type: Boolean,
        value: false
      },
      // Need to set a bool to know when speed has changed to update the
      // initial slideshow time w/o having to re-calc the time every time they open it
      speedHasChanged: {
        type: Boolean,
        value: false
      },
      // All time listed below is in Milliseconds
      slideshowTransitionTime: {
        type: Number,
        value: 700
      },
      slideDisplayTime: {
        type: Number,
        value: 4000
      },
      displayedSlideshowDuration: {
        type: Number,
        value: 0
      },
      totalSlideshowDurationWithAudio: {
        type: Number,
        value: 0
      },
      totalSlideshowDurationWithoutAudio: {
        type: Number,
        value: 0
      },
      currentSlideIndex: {
        type: Number,
        value: 0
      },
      slideshowCountAndTime: {
        type: String,
        value: ''
      },
      audioCurrentTime: {
        type: String,
        value: '0:00'
      },
      speedSelection: {
        type: String,
        value: 'normal'
      },
      // Allowing the setTimeout to be ended (to clean up timer) when slideshow closes
      slideDisplayTimeout: {
        type: String,
        value: ''
      },
      slideshowControlsTimeout: {
        type: String,
        value: ''
      },
      shareSlideshowEx: {
        type: Boolean,
        value: function(){ return FS.showEx('shareSlideshowEx'); }
      }
    },

    ready: function() {
      this.listen(document, 'gallery-view-changed', 'handleGalleryViewChanged');
      document.addEventListener('keyup', this.handleKeyPress.bind(this));
      // Fullscreenchange event isn't standardized yet
      /* Standard syntax */
      this.$.slideShow.addEventListener('fullscreenchange', this.exitHandler.bind(this));
      /* Safari and Opera */
      this.$.slideShow.addEventListener('webkitfullscreenchange', this.exitHandler.bind(this));
      /* Firefox */
      this.$.slideShow.addEventListener('mozfullscreenchange', this.exitHandler.bind(this));
      /* IE / Edge */
      this.$.slideShow.addEventListener('msfullscreenchange', this.exitHandler.bind(this));
      // Events for showing slideshow controls
      this.$.slideShow.addEventListener('mousemove', this.handleMouseMove.bind(this));
      this.$.slideShow.addEventListener('click', this.showControlsOnly.bind(this));
      this.$.slideShow.addEventListener('touchstart', this.showControlsOnly.bind(this));
      this.$.slideshowControls.addEventListener('mouseenter', this.handleMouseEnter.bind(this, true));
      this.$.slideshowControls.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
      this.fire('gallery-fs-album-slideshow-ready');
    },

    // None of the "ESC" keyboard events work when in fullscreen
    exitHandler: function (e) {
      // fullscreenElement is 'null' when leaving fullscreen mode
      if (!document.fullscreenElement) {
        this.$.slideShow.close();
        this.pauseCurrentAudio();
      }
    },

    handlePlayPauseSlideshow: function(e) {
      this.blurButton(e);
      if (this.isSlideshowPaused) {
        this.isSlideshowPaused = false;
        this.stopSlideshow = false;
        this.runSlides();
      } else {
        // Pause the slideshow too
        this.stopSlideshow = true;
        clearTimeout(this.slideDisplayTimeout);
        this.pauseCurrentAudio(false);
        this.isSlideshowPaused = true;
      }
    },
    handlePrevSlide: function(e) {
      this.blurButton(e);
      this.pauseCurrentAudio();
      this.stopSlideshow = true;
      clearTimeout(this.slideDisplayTimeout);
      this.isSlideshowPaused = false;
      this.prevSlide();
    },
    handleNextSlide: function(e) {
      this.blurButton(e);
      this.pauseCurrentAudio();
      this.stopSlideshow = true;
      clearTimeout(this.slideDisplayTimeout);
      this.isSlideshowPaused = false;
      this.nextSlide();
    },

    handleKeyPress: function(e) {
      if (!this.isSlideshowOpen()) return;
      switch (e.key) {
        case " ": /* SPACE */
          this.handlePlayPauseSlideshow(e);
          break;
        case "ArrowLeft": /* Left Arrow */
          this.handlePrevSlide(e);
          break;
        case "ArrowRight": /* Right Arrow */
          this.handleNextSlide(e);
          break;
      
        default:
          break;
      }
    },

    /**
     * Resets some dynamic variables used in the slideshow
     */
    reset: function() {
      this.showAudioError = false;
      // Stop audio and reset track to beginning (they may have stopped on the first slide)
      this.pauseCurrentAudio();
      this.currentSlideIndex = 0;
      this.audioTracks = [];
    },

    /**
     * Closes the slideshow options dialog if open and the browser back button is clicked
     */
    closeSlideshowOptions: function() {
      const slideshowOptions = this.$.slideshowOptions;
      if (slideshowOptions.opened) slideshowOptions.close();
      this.speedSelection = "normal";
    },

    /**
     * Opens the initial slideshow options dialog
     */
    openSlideshowOptions: function(data) {
      const validArtifacts = (data.artifacts && data.artifacts.length) ? this.validateArtifacts(data.artifacts) : [];
      this.reset();
      this.displayedSlideshowDuration = 0;
      this.set('artifacts', validArtifacts);
      this.stopSlideshow = false;
      this.isSlideshowFinished = false;
      this.setSlideshowCountAndTime();
      this.$.slideshowOptions.open();
    },
    
    /**
     * Returns the "valid" set of artifacts in the album that can be used in the slideshow
     * The currently valid types are:
     * [Category] > [Content Category]
     *    - IMAGE > PHOTOS (with or without associated audio files)
     *    - IMAGE > DOCUMENT
     */
    validateArtifacts: function(artifacts) {
      // Don't need to check for 'Phaudios' since they will always be included with a photo filter 
      const validGroup = artifacts.filter(item => (item.artifactDisplayState === 'APPROVED' && item.category === 'IMAGE' && (item.contentCategory === 'PHOTO' || item.contentCategory === 'DOCUMENT')));
      return validGroup.slice(0);
    },

    // Slide animation transitions
    fadeInSlide: function() {
      this.$.slideImage.style.animation = `300ms ease-in forwards fadeIn`;
    },
    fadeOutSlide: async function() {
      this.$.slideImage.style.animation = `${this.slideshowTransitionTime}ms ease-out forwards fadeOut`;
      // Reduce the time a bit to avoid blank screen while next image renders
      await this.timer(300); 
      return true;
    },
    shouldToggleFade: function(isSlideshowFinished) {
      return isSlideshowFinished ? 'fadeInAnimation' : 'fadeOutAnimation';
    },
    autoFadeoutControls: async function() {
      await this.timer(2000, true);
      this.showControls = false;
    },

    /**
     * Restarts slideshow. Only called when looping is not enabled
     */
    restartSlideshow: async function() {
      this.isSlideshowFinished = false;
      this.currentSlideIndex = 0;
      await this.fadeOutSlide();
      this.runSlides();
    },

    /**
     * Moves to the next slide
     */
    nextSlide: async function() {
      this.showAudioError = false;
      if ((this.currentSlideIndex + 1) < this.artifacts.length) {
        await this.fadeOutSlide();
        this.currentSlideIndex += 1;
      } else if (this.currentSlideIndex === (this.artifacts.length - 1)) {
        if (this.loopSlideshow) {
          await this.fadeOutSlide();
          this.currentSlideIndex = 0;
          // Accounting for when you have one slide and have looping on
          if (this.artifacts.length === 1) this.fadeInSlide();
        } else {
          this.isSlideshowFinished = true;
          return;
        }
      }
      this.isSlideshowFinished = false;
      if (this.stopSlideshow) this.stopSlideshow = false;
      this.runSlides();
    },

    /**
     * Moves to the previous slide
     */
    prevSlide: async function() {
      this.showAudioError = false;
      // If 'fadeOutSlide' is moved out here the slide would fade on a non-looping prev click on the first slide
      if ((this.currentSlideIndex - 1) >= 0) {
        await this.fadeOutSlide();
        this.currentSlideIndex -= 1;
      } else if ((this.currentSlideIndex === 0) && this.loopSlideshow) {
        await this.fadeOutSlide();
        this.currentSlideIndex = this.artifacts.length - 1;
      }
      this.isSlideshowFinished = false;
      if (this.stopSlideshow) this.stopSlideshow = false;
      this.runSlides();
    },

    /**
     * Timer to pause slide progression for the determined amount of time
     */
    timer: function(delay, isControls = false) {
      return new Promise(res => {
        if (isControls) {
          this.slideshowControlsTimeout = setTimeout(res, delay);
        } else {
          this.slideDisplayTimeout = setTimeout(res, delay);
        }
      });
    },

    /**
     * Manages audio slide error checks, and delayTime updates
     */
    handleAudioSlideChecks: async function(delayTime, artifact) {
      let player = this.getAudioPlayer();
      if (artifact.hasAudioErr || !artifact.slideLength) {
        this.showAudioError = true;
      } else {
        try {
          await player.play();
          this.isAudioPlaying = true;
        } catch (error) { // Error playing the audio
          player = {
            duration: this.slideDisplayTime,
            currentTime: 0
          }
          artifact.hasAudioErr = true;
        }
        // Allow delay to be reduced if audio is "resumed" from a paused state
        const duration = isNaN(player.duration) ?  0 : player.duration * 1000;
        const current = player.currentTime * 1000;
        if (current !== 0) delayTime = (duration - current);
      }
      return delayTime;
    },

    /**
     * Manages slide progression
     */
    runSlides: async function() {
      if (this.stopSlideshow) return;
      const artifact = this.artifacts[this.currentSlideIndex];
      let delayTime = (this.playAudio && !artifact.hasAudioErr && artifact.slideLength) ? artifact.slideLength : this.slideDisplayTime;
      if (this.playAudio && artifact.hasPhaudio) {
        delayTime = await this.handleAudioSlideChecks(delayTime, artifact);
      } else {
        // Adjust slide based on slide speed setting
        if (this.speedSelection !== 'normal') delayTime *= parseFloat(this.speedSelection);
      }
      await this.timer(delayTime);
      if (!this.stopSlideshow) this.nextSlide();
    },

    /**
     * Opens and kicks-off the slideshow
     */
    beginSlideshow: function(e) {
      if (e.target.id === 'slideshowOptions' && this.artifacts.length) {
        const slideShow = this.$.slideShow;
        this.$.slideshowOptions.close();
        this.runSlides();
        slideShow.open();
        // iOS doesn't support 'requestFullscreen' even with Polyfill
        if (slideShow.requestFullscreen) slideShow.requestFullscreen();
        this.autoFadeoutControls();
      }
    },

    /**
     * Stops slideshow and resets slideshow state
     */
    handleSlideshowClose: function(e) {
      if (Polymer.dom(e).localTarget.id === 'slideShow' || e.currentTarget.id === 'slideShowEnd') {
        clearTimeout(this.slideDisplayTimeout);
        if (document.fullscreenElement) document.exitFullscreen();
        this.reset();
        if (this.$.slideshowSpeedModal.opened) this.$.slideshowSpeedModal.close();
        this.stopSlideshow = true;
      }
    },

    /**
     * Handler for when the meta data is loaded for the audio file.
     * Updates the 'totalSlideshowDurationWithAudio' value with audio's duration
     */
    handleAudioDataLoaded: function(audioEl, artifactIndex) {
      let offset = 0;
      const dur = (audioEl.duration * 1000); // Audio duration is given in seconds
      // Phaudios shouldn't prevent photo from showing for at least the 'slideDisplayTime'
      if (dur < this.slideDisplayTime) offset = this.slideDisplayTime - dur;
      this.artifacts[artifactIndex].slideLength = (dur + offset);
      this.totalSlideshowDurationWithAudio += (dur + this.slideshowTransitionTime + offset);

      if (this.playAudio) {
        this.artifacts[artifactIndex].phaudioDuration = audioEl.duration;
        this.displayedSlideshowDuration = this.playAudio ? this.totalSlideshowDurationWithAudio : this.totalSlideshowDurationWithoutAudio;
        this.setSlideshowCountAndTime();
      }
    },

    /**
     * Handler for when we know an audio file has an error from the start
     */
     handleAudioError: function(artifactIndex) {
      this.artifacts[artifactIndex].hasAudioErr = true;
    },

    /**
     * Obtain the audio file duration via the Audio API
     */
    getAudioDuration: function(audioUrl, artifactIndex) {
      const audioEl = new Audio(audioUrl);
      audioEl.addEventListener('loadedmetadata', () => { this.handleAudioDataLoaded(audioEl, artifactIndex) });
      audioEl.addEventListener('error', () => { this.handleAudioError(artifactIndex) });
      audioEl.addEventListener('timeupdate', () => { this.updateAudioTime(audioEl, artifactIndex) });
      // Add audio to array to avoid dup loading of audio track
      this.push('audioTracks', { audioEl, artifactIndex });
    },

    /**
     * Determines the duration of the slideshow, with and without audio playing.
     */
    calcSlideshowDuration: function() {
      const nonAudioSlideTime = (this.slideDisplayTime + this.slideshowTransitionTime);
      // Add up all slide times (all images show regardless of audio playing)
      this.totalSlideshowDurationWithoutAudio = (this.artifacts.length * nonAudioSlideTime);
      this.totalSlideshowDurationWithAudio = 0;

      this.artifacts.forEach((item, index) => {
        let audioIndex = -1;
        if (item.associatedArtifacts && item.associatedArtifacts.artifact.length) {
          audioIndex = item.associatedArtifacts.artifact.findIndex(associated => associated.category === 'AUDIO');
        }
        if (audioIndex >= 0) {
          item.hasPhaudio = true;
          item.associatedAudioIndex = audioIndex;
          // Get Audio time and add it to totalSlideshowDurationWithAudio
          this.getAudioDuration(item.associatedArtifacts.artifact[audioIndex].url, index);
        } else {
          // Add all the non-audio slide times to 'totalSlideshowDurationWithAudio'
          this.totalSlideshowDurationWithAudio += nonAudioSlideTime;
          item.slideLength = this.slideDisplayTime;
        }
      });

      this.displayedSlideshowDuration = this.playAudio ? this.totalSlideshowDurationWithAudio : this.totalSlideshowDurationWithoutAudio;
    },

    /**
     * Formats the slideshow time shown in a "[minutes]:[seconds (2-digit)]" format
     */
    formatDisplayTime: function(timeInMS) {
      const minutes = (Math.floor(Math.floor(timeInMS / 1000) / 60) % 60);
      const seconds = (Math.floor(timeInMS / 1000) % 60);
      const formattedSeconds = (seconds < 10) ? `0${seconds}` : seconds;
      return `${minutes}:${formattedSeconds}`;
    },

    /**
     * Updates the displayed slide count and slideshow duration
     */
    setSlideshowCountAndTime: function() {
      if (!this.i18n) return;
      let text = this.i18n('slideshow_options_length');
      if (text) {
        if ((!this.displayedSlideshowDuration || this.speedHasChanged) && this.artifacts.length) this.calcSlideshowDuration();
        this.speedHasChanged = false;
        text = text.replace('{count}', `<span>${this.artifacts.length}</span>`);
        text = text.replace('{min}', `<span>${this.formatDisplayTime(this.displayedSlideshowDuration)}</span>`);
        this.slideshowCountAndTime = text;
      }
    },
    
    /**
     * Updates the displayed slide index reference - on slideshow controls
     */
    getSlideIndexPosition: function(currentSlideIndex, artifactsLength, i18n) {
      if (!i18n) return;
      let text = i18n('slideshow_controls_slide_number');
      if (text) {
        text = text.replace('{current}', currentSlideIndex + 1);
        text = text.replace('{total}', artifactsLength);
        return text;
      }
      return '';
    },

    openSlideshowSpeedModal: function(e) {
      this.blurButton(e);
      const speedModal = this.$.slideshowSpeedModal;
      const config = { attachToElement: e.currentTarget };
      speedModal.opened ? speedModal.close() : speedModal.open(config);
    },

    /**
     * Returns bool of if slideshow is open
     */
    isSlideshowOpen: function() {
      return !!this.$.slideShow.opened;
    },

    /**
     * Returns the 'url' from the current slide (for displaying the photo)
     */
    getCurrentSlideSrc: function(currentSlideIndex) {
      if (!this.artifacts || !this.artifacts.length) return '';
      const current = this.artifacts[currentSlideIndex];
      if (current.mimeType === 'image/tiff') {
        // Most browsers can't display Tiff files, have to use the generated jpg
        return current.deepZoomLiteUrl || current.thumbUrl;
      }
      return current.url;
    },
    /**
     * Returns the 'title' from the current slide (for 'alt' text)
     */
    getCurrentSlideAltText: function(currentSlideIndex) {
      if (!this.artifacts || !this.artifacts.length) return '';
      return this.artifacts[currentSlideIndex].title || '';
    },
    /**
     * Returns the 'associated audio' source from the current slide
     */
     getCurrentSlideAudioSrc: function(currentSlideIndex, artifactsLength) {
      if (!artifactsLength || !this.playAudio || !this.artifacts[currentSlideIndex].hasPhaudio) return '';
      const artifact = this.artifacts[currentSlideIndex];
      return artifact.associatedArtifacts.artifact[artifact.associatedAudioIndex || 0].url || '';
    },
    /**
     * Toggles the "play photo-audio" slider and updates the displayed slideshow duration
     */
    togglePlayAudio: function() {
      this.playAudio = !this.playAudio;
      this.displayedSlideshowDuration = this.playAudio ? this.totalSlideshowDurationWithAudio : this.totalSlideshowDurationWithoutAudio;
      this.setSlideshowCountAndTime();
    },
    /**
     * Toggles the "loop slideshow" slider
     */
    toggleLoopSlideshow: function(e) {
      this.blurButton(e);
      this.loopSlideshow = !this.loopSlideshow;
    },
    /**
     * Toggles the "loop slideshow" slider
     */
     isActiveLoopBtn: function(loopSlideshow) {
      return loopSlideshow ? 'active-loop-btn' : '';
    },
    /**
     * Determines if the Phaudio player should be shown
     */
    shouldShowPhaudioPlayer: function(currentSlideIndex, artifactsLength) {
      if (!artifactsLength) return false;
      return this.artifacts[currentSlideIndex].hasPhaudio && this.playAudio;
    },
    /**
     * Sets if the audio bars are animating or not
     */
    audioBarsActive: function(isAudioPlaying) {
      return isAudioPlaying ? 'playing-animation' : 'playing-animation paused';
    },
    updateAudioTime: function(audioEl, audioArtifactIndex) {
      if (audioArtifactIndex !== this.currentSlideIndex) return;
      const duration = isNaN(audioEl.duration) ?  0 : audioEl.duration * 1000;
      const current = audioEl.currentTime * 1000;
      this.isAudioPlaying = ((duration - current) !== 0 && !this.isSlideshowPaused);
      this.audioCurrentTime = this.formatDisplayTime(duration - current);
    },
    getPlayPauseString: function(isSlideshowPaused) {
      if (!this.i18n) return '';
      return isSlideshowPaused ? this.i18n('slideshow_controls_play') : this.i18n('slideshow_controls_pause')
    },
    updateSpeedSelection: function(e) {
      this.speedSelection = e.currentTarget.dataset.speed;
      this.speedHasChanged = true;
      // Update the slideshow time displayed on options modal based on new slide display speed
      this.setSlideshowCountAndTime();
      this.$.slideshowSpeedModal.close();
      this.isMouseEnter = false;
      this.autoFadeoutControls();
    },
    shouldShowCheckmark: function(speedSelection, buttonSpeed) {
      return speedSelection === buttonSpeed;
    },
    handleMouseLeave: function(e) {
      if (!this.$.slideshowSpeedModal.opened) {
        this.isMouseEnter = false;
        this.autoFadeoutControls();
      }
    },
    handleMouseEnter: function(e) {
      clearTimeout(this.slideshowControlsTimeout);
      this.isMouseEnter = true;
      this.showControls = true;
    },
    handleMouseMove: function(e) {
      this.debounce('mousemove', () => {
        this.showControls = true;
      }, 50);
    },
    showControlsOnly: function(e) {
      const isNotSlideshowControlsClick = (Polymer.dom(e).localTarget.id !== 'slideshowControls');
      if (e.type === 'touchstart') {
        this.showControls = isNotSlideshowControlsClick;
      } else {
        if (isNotSlideshowControlsClick) this.autoFadeoutControls();
        this.showControls = true;
      }
    },
    handleTouchEvent: async function() {
      if (!this.isSlideshowOpen()) return;
      clearTimeout(this.slideshowControlsTimeout);
      this.shouldToggleFade(true);
      await this.timer(2000, true);
      this.autoFadeoutControls();
    },
    updateControlsVisibility: function(showControls, isSlideshowFinished) {
      if (!this.isSlideshowOpen()) return;
      if (!isSlideshowFinished && showControls && !this.isMouseEnter) this.autoFadeoutControls();
      return isSlideshowFinished ? this.shouldToggleFade(false) : this.shouldToggleFade(showControls);
    },
    /**
     * Blurs the button clicked, so keyboard shortcuts are always functional
     */
    blurButton: function(e) {
      // If a keypress was used e.currentTarget is 'document' which has no 'blur'
      if (e.currentTarget.blur) e.currentTarget.blur(e);
    },
    getAudioPlayer: function() {
      if (!this.audioTracks || !this.audioTracks.length) return false;
      const audioTrackIndex = this.audioTracks.findIndex(track => track.artifactIndex === this.currentSlideIndex);
      return (audioTrackIndex >= 0) ? this.audioTracks[audioTrackIndex].audioEl : false;
    },
    pauseCurrentAudio: function(resetTime = true) {
      const player = this.getAudioPlayer();
      if (player) {
        player.pause();
        if (resetTime) player.currentTime = 0;
      }
    },
    handleGalleryViewChanged: function(e) {
      // If the gallery view is being set to its initial state, leave the slideshow open
      if (e.detail.oldValue && e.detail.oldValue !== e.detail.value) {
        this.closeSlideshowOptions();
      }
    },
    toggleSocialMenu: function(e) {
      // Prevents the menu from immediately closing
      e.stopPropagation();
      const socialMenu = this.$$('fs-social-menu');
      socialMenu.config = {
        uri: window.location.pathname + '?playSlideshow'
      };
      this.$$('fs-social-menu').toggle({
        target: e.target
      });
    }
  });
})();
</script>
